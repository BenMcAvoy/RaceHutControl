//! Purpose: Generate the `src/classes.rs` file from the `classes.txt` file.
//! This is so that the `ClassList` component can be implemented with a dynamic list of classes.
//! This method prevents the need for embedding or dragging around extra files with the binary.

use std::io::prelude::*;

const HEADER: &str = "//! This file is generated by the build script.
//! Do not modify it manually. Modify `classes.txt` instead.
//!
//! It is used for the `ClassList` component to display a dynamic list of classes.

";

const FN_START: &str = "/// Get the list of classes as a vector of string slices
pub fn get_classes() -> Vec<&'static str> {
    vec![
";

const FN_END: &str = "    ]
}
";

const ENUM_START: &str = "
#[derive(PartialEq, Clone)]
pub enum Class {
";

const ENUM_END: &str = "}
";

const FROM_STR_IMPL: &str = "
impl Class {
    /// Convert a string to a Class enum
    pub fn from_str(class: &str) -> Option<Self> {
        match class {";

const FROM_STR_END: &str = "
            _ => None,
        }
    }
}";

const ENUM_IMPL_START: &str = "
impl std::fmt::Debug for Class {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
";

const ENUM_IMPL_END: &str = "        }
    }
}";

fn main() {
    // Load `classes.txt` file
    let classes = std::fs::read_to_string("classes.txt").unwrap();

    // Write the output file as append mode but clear it upon opening. Also create it if it doesn't
    // already exist
    let mut output = std::fs::OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open("src/classes.rs")
        .unwrap();

    let mut output_builder = String::new();

    output_builder.push_str(HEADER);

    output_builder.push_str(FN_START);

    for class in classes.lines() {
        output_builder.push_str(&format!("        \"{}\",\n", class));
    }

    output_builder.push_str(FN_END);

    output_builder.push_str(ENUM_START);

    for class in classes.lines() {
        output_builder.push_str(&format!("    B{},\n", class));
    }

    output_builder.push_str(ENUM_END);

    output_builder.push_str(ENUM_IMPL_START);

    for class in classes.lines() {
        output_builder.push_str(&format!(
            "            Class::B{} => write!(f, \"{}\"),\n",
            class, class
        ));
    }

    output_builder.push_str(ENUM_IMPL_END);

    output_builder.push_str(FROM_STR_IMPL);

    for class in classes.lines() {
        output_builder.push_str(&format!(
            "            \"{}\" => Some(Class::B{}),\n",
            class, class
        ));
    }

    output_builder.push_str(FROM_STR_END);

    output.write_all(output_builder.as_bytes()).unwrap();
}
